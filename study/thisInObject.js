


/*this В СТРЕЛОЧНЫХ ФУНКЦИЯХ ОПРЕДЕЛЯЕТСЯ ЛЕКСИЧЕСКИМ КОНТЕКСТОМ, Т.Е. МЕСТОМ, ГДЕ ФУНКЦИЯ БЫЛА СОЗДАНА.
  this В ОБЫЧНЫХ ФУНКЦИЯХ ОПРЕДЕЛЯЕТСЯ МЕСТОМ ВЫЗОВА ФУНКЦИИ*/

function makeUser() {
    return {
        name: "Джон",
        ref: this
    };
};

let user = makeUser();

alert(user.ref.name);  // Error: Cannot read property 'name' of undefined

/*[learn.javascript]Это потому, что правила, которые определяют значение this, никак не смотрят на объявление объекта.
 Важен лишь момент вызова метода. Здесь значение this внутри makeUser() является undefined,
  потому что makeUser() вызвана как функция, не через «точку» как метод. Литерал объекта 
  сам по себе не влияет на this. Значение this одно для всей функции и блоков кода в ней, 
  литеральные объекты не меняют его.
Таким образом, при создании объекта ref: this берёт текущее значение this функции makeUser().

противоположный случай:
*/

function makeUser() {
    return {
      name: "Джон",
      ref() {
        return this;
      }
    };
  };
  
  let user = makeUser();
  
  alert( user.ref().name ); 

  /* [me] В данном случае this не инициализируется при вызове makeUser() (как  в предыдущем
    примере) потому что 

    ****При объявлении любой функции в ней можно использовать this, 
    но этот this не имеет значения до тех пор, пока функция не будет вызвана.****

    То есть при вызове makeUser создаётся литерал объекта с полем name: Джон и методом ref(),
    в котором this не инициализирована поскольку функция не вызвана.

  */
